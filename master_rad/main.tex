% Format teze zasnovan je na paketu memoir
% http://tug.ctan.org/macros/latex/contrib/memoir/memman.pdf ili
% http://texdoc.net/texmf-dist/doc/latex/memoir/memman.pdf
% 
% Prilikom zadavanja klase memoir, navedenim opcijama se podešava 
% veličina slova (12pt) i jednostrano štampanje (oneside).
% Ove parametre možete menjati samo ako pravite nezvanične verzije
% mastera za privatnu upotrebu (na primer, u b5 varijanti ima smisla 
% smanjiti 
\documentclass[12pt,oneside]{memoir} 

% Paket koji definiše sve specifičnosti master rada Matematičkog fakulteta
\usepackage[latinica]{matfmaster} 

\usepackage[bottom]{footmisc}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{enumitem}
\usepackage{subfigure}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{corollary}[theorem]{Korolar}
% \usepackage{algpseudocode}
\usepackage{listings}
\usepackage{bm}
\usepackage{multirow}

\usepackage{array}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage{float}


% Define a custom color
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codegreen}{rgb}{0,0.6,0}

% Define a custom style
\lstdefinestyle{myStyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    keepspaces=true,                 
    numbers=left,       
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
}

% Use \lstset to make myStyle the global default
\lstset{style=myStyle}

\makeatletter
\renewcommand{\ALG@name}{Algoritam}
\makeatother
%
% Podrazumevano pismo je ćirilica.
%   Ako koristite pdflatex, a ne xetex, sav latinički tekst na srpskom jeziku
%   treba biti okružen sa \lat{...} ili \begin{latinica}...\end{latinica}.
%
% Opicija [latinica]:
%   ako želite da pišete latiniciom, dodajte opciju "latinica" tj.
%   prethodni paket uključite pomoću: \usepackage[latinica]{matfmaster}.
%   Ako koristite pdflatex, a ne xetex, sav ćirilički tekst treba biti
%   okružen sa \cir{...} ili \begin{cirilica}...\end{cirilica}.
%
% Opcija [biblatex]:
%   ako želite da koristite reference na više jezika i umesto paketa
%   bibtex da koristite BibLaTeX/Biber, dodajte opciju "biblatex" tj.
%   prethodni paket uključite pomoću: \usepackage[biblatex]{matfmaster}
%
% Opcija [b5paper]:
%   ako želite da napravite verziju teze u manjem (b5) formatu, navedite
%   opciju "b5paper", tj. prethodni paket uključite pomoću: 
%   \usepackage[b5paper]{matfmaster}. Tada ima smisla razmisliti o promeni
%   veličine slova (izmenom opcije 12pt na 11pt u \documentclass{memoir}).
%
% Naravno, opcije je moguće kombinovati.
% Npr. \usepackage[b5paper,biblatex]{matfmaster}

% Pomoćni paket koji generiše nasumičan tekst u kojem se javljaju sva slova
% azbuke (nema potrebe koristiti ovo u pravim disertacijama)
% Datoteka sa literaturom u BibTex tj. BibLaTeX/Biber formatu
\bib{matfmaster}

% Ime kandidata na srpskom jeziku (u odabranom pismu)
\autor{Nikola Belaković}
% Naslov teze na srpskom jeziku (u odabranom pismu)
\naslov{Algoritmi za rešavanje problema Hornovog jezgra}
% Godina u kojoj je teza predana komisiji
\godina{2024}
% Ime i afilijacija mentora (u odabranom pismu)
\mentor{dr Aleksandar \textsc{Kartelj}, vanredni profesor\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija prvog člana komisije (u odabranom pismu)
\komisijaA{dr Predrag \textsc{Janičić}, redovni profesor\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija drugog člana komisije (u odabranom pismu)
\komisijaB{dr Vladimir \textsc{Filipović}, redovni profesor\\ Univerzitet u Beogradu, Matematički fakultet}
% Ime i afilijacija trećeg člana komisije (opciono)
% \komisijaC{}
% Ime i afilijacija četvrtog člana komisije (opciono)
% \komisijaD{}
% Datum odbrane (odkomentarisati narednu liniju i upisati datum odbrane ako je poznat)
% \datumodbrane{}

% Apstrakt na srpskom jeziku (u odabranom pismu)
\apstr{
Ovaj rad istražuje primenu metaheurističkih tehnika za rešavanje problema pronalaska maksimalnog Hornovog jezgra, sa posebnim fokusom na metodu promenljivih okolina (\textit{eng.} Variable Neighborhood Search) i pohlepnu pretragu (\textit{eng.} Greedy search). Problem pronalaska maksimalnog Hornovog jezgra je složen optimizacioni problem koji zahteva efikasne metode za pretragu velikog prostora rešenja. U okviru ovog istraživanja, analizirane su performanse pomenutih metaheuristika kroz eksperimente izvedene na različitim test podacima, uz poređenje sa metodom grube sile. U radu je detaljno opisan problem i konstrukcija pomenutih algoritama i heuristika. Opisan je način na koji su generisane test instance problema i dat je prikaz rezultata na različitim instancama. Pored toga, rad se bavi razvojem i evaluacijom algoritma za generisanje Hornove formule iz skupa modela. Takođe, razmotrene su ideje za buduće usavršavanje predstavljenih algoritama, kao i mogućnosti za razvoj novih metoda.
}

% Ključne reči na srpskom jeziku (u odabranom pismu)
\kljucnereci{optimizacija, Hornovo jezgro, metaheurističke tehnike, metoda promenljivih okolina, pohlepna pretraga, algoritam generisanja formule}

\begin{document}
% ==============================================================================
% Uvodni deo teze
\frontmatter
% ==============================================================================
% Naslovna strana
\naslovna
% Strana sa podacima o mentoru i članovima komisije
\komisija
% Strana sa posvetom (u odabranom pismu)
\posveta{Hvala profesoru Aleksandru Kartelju.}
% Strana sa podacima o disertaciji na srpskom jeziku
\apstrakt
% Sadržaj teze
\tableofcontents*

% ==============================================================================
% Glavni deo teze
\mainmatter
% ==============================================================================

% ------------------------------------------------------------------------------
\chapter{Uvod}
% ------------------------------------------------------------------------------
% \pangrami
Problem pronalaska maksimalnog Hornovog jezgra (eng. maximum Horn core problem) spada u manje poznate NP-teške probleme optimizacije u domenu logike. Ovaj problem se može opisati kao pronalaženje najvećeg podskupa modela \(M'\) iz skupa \(M\), takvog da postoji Hornova formula čiji je skup modela jednak \(M'\) \cite{HCproblem}.

Hornove formule imaju široku primenu u oblastima logike \cite{doc43,doc2}, računarstva i veštačke inteligencije, posebno u automatskom zaključivanju \cite{doc41,doc42}. Zahvaljujući ovoj širokoj primeni, sve veći broj istraživača se bavi problemima povezanim sa Hornovim formulama. Jedan od tih problema, problem pronalaska maksimalnog Hornovog jezgra, obrađen je u ovom radu i za njega je dokazano da je NP-kompletan \cite{doc3}.



Jedan od algoritama za rešavanje problema maksimalnog Hornovog jezgra predstavljen je u radu \cite{doc1}. Ovaj algoritam, čiji će detaljan opis biti predstavljen u Glavi \ref{chap:chapter2}, korišćen je u ovom istraživanju. Testirana je optimizacija korišćenjem pohlepnog algoritma (\textit{eng.} greedy search) i metode promenljivih okolina (\textit{eng.} variable neighborhood search).

U nastavku ovog uvodnog poglavlja, formalno će biti definisan problem pronalaska maksimalnog Hornovog jezgra i prikazan pregled dosadašnjih istraživanja na ovu temu.

\newpage



\section{Problem pronalaska maksimalnog Hornovog jezgra}
U ovom poglavlju formalno će biti definisan problem pronalaska maksimalnog Hornovog jezgra, ali pre toga je potrebno definisati i neke bitne pojmove za razumevanje problema.

Literal je osnovna jedinica u iskaznoj logici koja predstavlja atomičku formulu (poznatu i kao atom ili osnovna formula) ili njenu negaciju \cite{doc_lit}. Klauza je disjunkcija jednog ili više literala. Hornova klauza je klauza koja sadrži najviše jedan pozitivan literal \cite{doc_horn_clause}. Konjunktivna normalna forma (CNF) je logički izraz koji se sastoji od konjunkcije jedne ili više disjunkcija literala. Hornova formula je specifična vrsta formule u CNF-u koja se sastoji isključivo od Hornovih klauza \cite{doc3}.


Model $t$ je skup $\{0, 1\}^n$ istinitosnih valuacija logičkih promenljivih. Model t zadovoljava klauzu ako je neki literal klauze $x_i$ i $t_i=1$ ili je neki literal klauze $\neg x_i$ i $t_i=0$ -- $t_i$ predstavlja vrednost $i$-te iskazne promenljive u valuaciji $t$. Neka je dat skup $M$ modela nad $n$ iskaznih promenljivih. Hornovo jezgro skupa $M$ je podskup $M'$ za koji postoji Hornova formula takva da je $M'$ skup svih njenih modela -- svaki član skupa zadovoljava Hornovu formulu prema prethodnom opisu zadovoljivosti, dok nijedan model izvan skupa $M'$ ne zadovoljava tu formulu. Funkcija cilja za problem pronalaska maksimalnog Hornovog jezgra je kardinalnost Hornovog jezgra i nju je potrebno maksimizovati \cite{doc3,HCproblem}.

Važno je napomenuti da maksimalno Hornovo jezgro, jezgro maksimalne kardinalnosti, nije jedinstveno. Jedan skup modela $M$ može imati više različitih Hornovih jezgara, svaki sa istim brojem istinitosnih valuacija koje zadovoljavaju neku Hornovu formulu \cite{doc3}.

\textbf{Primer:} Razmotrimo sledeći skup modela:
\begin{align*}
M &= \{ (0, 0, 0, 1), (0, 1, 0, 1), (1, 0, 1, 1), (0, 1, 1, 1) \}
\end{align*}

Da bismo pronašli maksimalno Hornovo jezgro, koristimo algoritam koji dodaje valuacije u jezgro i proverava da li njihova "konjunkcija", primena logičke operacije $\land$ na svaku poziciju u valuaciji, pripada skupu \(M\). Počinjemo sa valuacijom \((0, 0, 0, 1)\) i dodajemo je u jezgro. Zatim dodajemo valuaciju \((0, 1, 0, 1)\), jer je njena "konjunkcija" sa prvom valuacijom u \(M\). Sledeća valuacija, \((1, 0, 1, 1)\), takođe se dodaje jer njene "konjunkcije" sa prethodnim valuacijama pripadaju skupu \(M\). Međutim, valuacija \((0, 1, 1, 1)\) se ne dodaje, jer "konjunkcija" sa poslednjom dodanom valuacijom \((1, 0, 1, 1)\) daje:
\[
(1, 0, 1, 1) \land (0, 1, 1, 1) = (0, 0, 1, 1)
\] koja nije prisutna u skupu \(M\). Dakle, maksimalno Hornovo jezgro je:
\begin{align*}
\text{M}_{\text{core}} &= \{ (0, 0, 0, 1), (0, 1, 0, 1), (1, 0, 1, 1) \}
\end{align*}

Dato jezgro je skup modela formule:
\begin{align*}
\text{Formula} &= (\neg x_1 \land \neg x_2 \land \neg x_3 \land x_4) \lor (\neg x_1 \land  x_2 \land \neg x_3 \land x_4) \lor (x_1 \land \neg x_2 \land x_3 \land x_4)
\end{align*}

Ova formula je u disjunktivnoj normalnoj formi, a odgovarajuća formula u konjunktivnoj normalnoj formi je:
\begin{align*}
\text{Formula} &= (x_1 \lor x_2 \lor x_3 \lor x_4) \land (x_1 \lor x_2 \lor \neg x_3 \lor x_4) \land (x_1 \lor x_2 \lor \neg x_3 \lor \neg x_4) \\
& \land (x_1 \lor \neg x_2 \lor x_3 \lor x_4) \land (x_1 \lor \neg x_2 \lor \neg x_3 \lor x_4) \land (x_1 \lor \neg x_2 \lor \neg x_3 \lor \neg x_4) \\
& \land (\neg x_1 \lor x_2 \lor x_3 \lor x_4) \land (\neg x_1 \lor x_2 \lor x_3 \lor \neg x_4) \land (\neg x_1 \lor x_2 \lor \neg x_3 \lor x_4) \\
& \land (\neg x_1 \lor \neg x_2 \lor x_3 \lor x_4) \land (\neg x_1 \lor \neg x_2 \lor x_3 \lor \neg x_4) \land (\neg x_1 \lor \neg x_2 \lor \neg x_3 \lor x_4) \\
& \land (\neg x_1 \lor \neg x_2 \lor \neg x_3 \lor \neg x_4)
\end{align*}


Hornova formula koja je ekvivalentna ovim formulama i koja se može dobiti iz obe gore prikazane formule je:
\begin{align*}
\text{Formula} &= (\neg x_1 \lor \neg x_2 \lor \neg x_3) \land x_4 \land (x_1 \lor \neg x_3) \land (x_3 \lor \neg x_1)
\end{align*}

Modeli u maksimalnom Hornovom jezgru zadovoljavaju ovu formulu, što objašnjava zašto su ovi modeli deo Hornovog jezgra.

Za varijantu problema odlučivanja Hornovog jezgra je dokazano da je NP-kompletna u radu \cite{doc3}.

\section{Pregled dosadašnjih istraživanja}

Pojam Hornove formule prvi put je uveden od strane Alfreda Horna u njegovom radu "On sentences which are true of direct unions of algebras," koji je objavljen 1951. godine u časopisu \textit{Journal of Symbolic Logic} \cite{doc_horn_clause}. U ovom radu, Horn je proučavao posebnu klasu logičkih formula koje danas nazivamo Hornovim formulama, koje imaju specifičnu strukturu pogodnu za efikasno zaključivanje.

Razvoj pojma Hornovog jezgra započeo je 1991. godine kada je uveden pojam "najveća donja granica" (\textit{eng.} greatest lower bound) i dat prvi algoritam za rešavanje ovog problema pomoću leksikografskog sortiranja istinitosnih valuacija iz skupa modela \cite{doc2}. Ovaj pojam je uveden kao rezultat potrebe za efikasnijim sistemima za predstavljanje znanja koji ne ograničavaju izražajnu moć jezika za predstavljanje, niti se odriču potpunosti zaključivanja. Raniji radovi, kao što su oni Doylea i Patila (1991), te Horvitza (1989), bavili su se kompromisom između obradivosti i izražajnosti koristeći ograničene jezike ili nepotpune mehanizme zaključivanja \cite{doyle1991, horvitz1989}. Za razliku od tih pristupa, uvođenje Hornovog jezgra omogućava korišćenje opšteg, neograničenog jezika koji se kompajlira u ograničeni jezik, čime se postiže efikasno zaključivanje bez gubitka izražajne moći. Ovaj novi pristup omogućava pronalaženje najbolje aproksimacije originalne informacije, što dovodi do bržeg i pouzdanijeg zaključivanja.

Godine 1993., pojam "Hornovo jezgro" se prvi put spominje sa tim imenom \cite{doc3}. Ovaj rad je bio posvećen dokazivanju računske složenosti problema, a ne njegovom rešavanju.

Naredni razvoj dogodio se 1998. godine kada je rešen modifikovani problem pronalaska maksimalnog Hornovog jezgra. U ovom slučaju, tražena su Hornova jezgra disjunkcije Hornovih formula u konjunktivnoj normalnoj formi \cite{doc1}.

Pošto se metoda promenljivih okolina pokazao kao uspešna metaheuristika za rešavanje mnogih problema, u ovom istraživanju pristupilo se rešavanju problema korišćenjem ove metaheuristike i njenom poređenju sa algoritmom pohlepne pretrage. Ovaj pristup omogućava istraživanje različitih struktura rešenja i često daje bolje rezultate u poređenju sa tradicionalnim metodama kao što je pohlepna pretraga.


\chapter{Algoritmi za rešavanje problema pronalaska maksimalnog Hornovog jezgra}
\chaptermark{Predloženi algoritmi}
U ovom poglavlju biće dat pregled sledeće dve metaheuristike koje su koršćene za rešavanje problema pronalaska maksimalnog Hornovog jezgra:
\label{chap:chapter2}

\begin{enumerate}
  \item pohlepna pretraga (\textit{eng.} greedy search);
  \item metoda promenljivih okolina (\textit{eng.} variable neighborhood search).
\end{enumerate}
Osim ove dve metaheuristike, biće opisan i algoritam polinomske vremenske složenosti generisanja jednog Hornovog jezgra, koji je pomenut u prethodnom poglavlju, algoritam za generisanje Hornove formule iz skupa modela koje ta formula zadovoljava, kao i testni podaci koji su korišćeni za evaluaciju, uključujući i metodologiju njihovog generisanja..

\section{Algoritam pronalaska Hornovog jezgra}

Model je vektor $t \in \{0,1\}^n$, čija je $i$-ta komponenta označena sa $t_i$. Teorija je bilo koji skup $M \subseteq \{0,1\}^n$ modela. Nad modelima $t_j$ i $t_k$ se definiše bitovsko uređenje tako da za svaku komponentu $i$ vektora važi $t_j[i] \leq t_k[i]$, gde $0 \leq 1$ označava da je $0$ manja ili jednaka od $1$ u binarnom poređenju. Dakle, vektor $t_j$ je manji ili jednak vektoru $t_k$ ako nijedna komponenta vektora $t_j$ nije veća od odgovarajuće komponente vektora $t_k$.

Teorija je Hornova ako je $M = Cl_{\land}(M)$, gde je $Cl_{\land}(M)$ zatvorenje skupa $M \subseteq \{0,1\}^n$ za operaciju bitovske konjunkcije (tj. preseka) valuacija $t_i$ i $t_j$, označeno sa $t_i \land t_j$.

Hornova teorija $M'$ je Hornovo jezgro teorije $M$ ako je $M' \subseteq M$ i ne postoji Hornova teorija $M''$ takva da je $M' \subseteq M'' \subseteq M$. Primećujemo da, uopšteno, teorija $M$ može imati više od jednog Hornovog jezgra \cite{doc1}.

Iz ovog opisa Hornovog jezgra se može jednostavno formirati algoritam za pronalaženje jednog Hornovog jezgra teorije $M$. Na početku se Hornovo jezgro $M'$ inicijalizuje praznim skupom. Zatim se prolazi kroz sve komponente modela iz $M$ koje se prethodno mogu sortirati prema bitovskom uređenju i dodaju se u $M'$. Nakon toga se proverava da li je trenutni skup $M'$ zatvoren za konjunkciju, tako što se za svaki par $v, w \in M'$ proverava da li je $v \land w \in M'$. Ako jeste, dodata komponenta se zadržava u $M'$, a u suprotnom se izbacuje. Opisanim postupkom dobijamo jedno Hornovo jezgro početnog skupa modela $M$.\\

\begin{algorithm}
    \caption{Pronalazak Hornovog jezgra}
    \renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
    \renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
    \begin{algorithmic}[1]
        \REQUIRE Skup modela $M$
        \ENSURE Hornovo jezgro $M'$
    
        \STATE $M' \gets \emptyset$ 
        \STATE $M' \gets M' \cup \{m_1\}$
    
        \FOR{$i = 2$ \TO $n$}
            \STATE $M' \gets M' \cup \{m_i\}$
            \STATE $zadrzi\_komponentu \gets \text{True}$
            \FOR{$v, w \in M'$}
                \IF{$v \land w$ $\notin$ $M'$}
                    \STATE $zadrzi\_komponentu \gets \text{False}$
                    \STATE \textbf{break}
                \ENDIF
            \ENDFOR
            \IF{$\neg zadrzi\_komponentu$}
                \STATE $M' \gets M' \setminus \{ m_i \}$
            \ENDIF
        \ENDFOR
        \RETURN $M'$
        \end{algorithmic}
\end{algorithm}

\section{Pohlepna pretraga}
Algoritmi pohlepne pretrage donose odluke u svakom koraku na osnovu trenutno najboljeg izbora, bez obzira na posledice tih odluka u budućnosti. Zbog svoje jednostavnosti i brzine, pohlepna pretraga se često koristi u različitim oblastima, ali nije uvek garantovano da će pronaći globalno optimalno rešenje.

Pohlepna pretraga ima nekoliko prednosti i nedostataka koje je važno razmotriti prilikom njenog korišćenja. Jedna od glavnih predosti je brzina, zato što ovaj algoritam donosi odluke brzo, bez potrebe za pretraživanjem svih potencijalnih opcija. Takođe, ovaj algoritam je jednostavan za implementaciju i postoje određeni problemi u kojima će algoritam pohlepne pretrage pronaći globalno optimalno rešenje. Međutim, pohlepna pretraga ima i značajne nedostatke. Problem je što se može zaglaviti u lokalnom optimumu, i na taj način će pronaći dobro, ali ne i najbolje moguće rešenje. Zbog toga, upotreba ovog algoritma nije predviđena za probleme u kojima je ključno pronaći globalno optimalno rešenje \cite{cormen2022}.\\

\begin{algorithm}
\caption{Pohlepna pretraga}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
    \begin{algorithmic}[1]
\REQUIRE Početno rešenje $x$, maksimalan broj iteracija $maxIter$
\ENSURE Najbolje rešenje $x^*$

\STATE $x* \gets x$
\STATE $iter \gets 0$
\WHILE{$iter < maxIter$}
    \STATE $x' \gets \text{GenerišiSusednoRešenje}(x^*)$
    \IF{$f(x') < f(x^*)$}
        \STATE $x^* \gets x'$
    \ENDIF
    \STATE $iter \gets iter + 1$
\ENDWHILE

\RETURN $x^*$
\end{algorithmic}
\end{algorithm}

\section{Metoda promenljivih okolina}
Metoda promenljivih okolina (VNS) je metaheuristika za rešavanje problema optimizacije \cite{mladenovic1997}. 
VNS se bazira na tri jednostavne činjenice:
\begin{itemize}
    \item lokalni minimum za jednu okolinu ne mora biti minimum u odnosu na drugu okolinu;
    \item globalni minimum je lokalni minimum za sve okoline;
    \item za mnoge probleme, lokalni minimumi za razne okoline su relativno bliski.
\end{itemize}

Ova metoda se zasniva na ideji smena faza sistematičnih i nasumičnih (stohastičkih) promena okolina tokom pretrage prostora rešenja, čime se izbegava lokalni optimum i povećava šansa za pronalaženje globalnog optimuma. Njeni osnovni principi su:
\begin{itemize}
    \item \textbf{definisanje početnog rešenja} - pretraga počinje od nekog početnog rešenja, koje može biti nasumično generisano ili dobijeno nekom heuristikom;
    \item \textbf{razmrdavanje (\textit{eng.} shaking}) - promena trenutnog rešenja slučajnim izborom rešenja iz trenutne okoline, koja ima za cilj izlazak iz lokalnog optimuma i pomeranje u novo, potencijalno bolje rešenje;
    \item \textbf{popravljanje} - lokalnom pretragom se od izabranog rešenja iz faze razmrdavanja dolazi do lokalnog optimuma u njegovoj okolini;
    \item \textbf{pomeranje} - ako lokalna pretraga pronađe bolje rešenje od trenutno najboljeg rešenja, pretraga se nastavlja oko tog rešenja. U suprotnom, menja se okolina za razmrdavanje kako bi se istražila nova okruženja potencijalnih rešenja;
    \item \textbf{zaustavljanje} - pretraga se završava kada je ispunjen određeni kriterijum zaustavljanja, kao što je vreme izvršavanja algoritma ili maksimalan broj iteracija \cite{mladenovic2009}.
\end{itemize}

Metoda VNS ima mnoge prednosti koje je čine efikasnim alatom za rešavanje problema optimizacije, što je čini popularnim izborom među istraživačima. Njena jednostavna implementacija i fleksibilnost omogućavaju primenu na širok spektar problema. Jedan od ključnih prednosti je sposobnost izbegavanja lokalnih optimuma. Faza razmrdavanja i promena okolina pretrage pružaju mogućnost istraživanja većeg dela prostora rešenja, povećavajući šanse za pronalaženje globalnog optimuma. VNS je skalabilan i može se prilagoditi za rad sa velikim instancama problema, čemu doprinosi i njegova efikasnost za pronalaženje kvalitetnog rešenja u kratkom vremenskom okviru \cite{mladenovic2010}.\\

\begin{algorithm}[H]
\caption{Metoda promenljivih okolina}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE Početno rešenje $x$, skup okolina $\{N_1, N_2, \ldots, N_k\}$, maksimalan broj iteracija $maxIter$
\ENSURE Najbolje rešenje $x^*$
\STATE $x^* \gets x$
\STATE $iter \gets 0$
\WHILE{$iter < maxIter$}
    \STATE $x' \gets \text{LokalnaPopravka}(x^*)$ 
    \STATE $k \gets 1$
    \WHILE{$k \leq k_{max}$}
        \STATE $x'' \gets \text{Razmrdavanje}(x', N_k)$ 
        \STATE $x''' \gets \text{LokalnaPretraga}(x'')$ 
        \IF{$f(x''') < f(x^*)$}
            \STATE $x^* \gets x'''$
            \STATE $k \gets 1$
        \ELSE
            \STATE $k \gets k + 1$
        \ENDIF
    \ENDWHILE
    \STATE $iter \gets iter + 1$
\ENDWHILE
\RETURN $x^*$
\end{algorithmic}
\end{algorithm}


\section{Algoritam generisanja Hornove formule na osnovu skupa modela}

Ovaj algoritam generiše Hornovu formulu na osnovu skupa modela (istinitosne tablice). Proces je sistematičan i podeljen u nekoliko ključnih koraka. Cilj je da se identifikuju zajednički elementi modela, formiraju kombinacije koje zadovoljavaju sve modele i na kraju da se formira i pojednostavi formula do Hornove forme.

Prvo, algoritam identifikuje zajedničke jedinice u svim modelima. Ovo su pozicije gde svaki model ima vrednost 1 (tačno).

\begin{algorithm}[H]
\caption{Prepoznavanje zajedničkih jedinica}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE Skup modela $M$
\ENSURE Indeksi zajedničkih jedinica $I$
\STATE $I \gets \emptyset$
\FOR{$i = 1$ \TO $|M|-1$}
    \STATE $sve\_jedinice \gets \text{True}$
    \FOR{$m \in M$}
        \IF{$m_i \neq 1$}
            \STATE $sve\_jedinice \gets \text{False}$
            \STATE \textbf{break}
        \ENDIF
    \ENDFOR
    \IF{$sve\_jedinice$}
        \STATE $I \gets I \cup \{ i \}$
    \ENDIF
\ENDFOR
\RETURN $I$
\end{algorithmic}
\end{algorithm}

\textbf{Primer:} Razmotrimo Hornovo jezgro 
\[
M = \{(0, 0, 0, 1), (0, 1, 0, 1), (1, 0, 1, 1)\}\text{.}
\]
Pretražuju se sve pozicije u modelima da bi se pronašle zajedničke jedinice. U ovom slučaju, samo je pozicija 3 (indeksiranje od 0) zajednička za sve modele. Dakle, $I = \{3\} $.

Identifikacija zajedničkih jedinica osigurava da su ove pozicije prisutne u svim modelima. Na osnovu tih zajedničkih jedinica formira se klauza koja mora biti zadovoljena u svakom modelu u skupu. U ovom slučaju, formira se klauza $x_4$. Ovaj korak garantuje da formula ostaje tačna za sve modele u skupu.

Nakon što su zajedničke jedinice identifikovane, sledeći korak je skraćivanje modela uklanjanjem tih jedinica. Ovo omogućava efikasniju obradu u kasnijim koracima.\\

\begin{algorithm}[H]
\caption{Skraćivanje modela}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE Skup modela $M$, skup zajedničke jedinica $I$
\ENSURE Skraćeni modeli $M'$
\STATE $M' \gets \emptyset$
\FOR{$m \in M$}
    \STATE $m' \gets ""$
    \FOR{$i=1$ \TO $|m|-1$}
        \IF{$i \notin J$}
            \STATE $m'_i \gets m_i$
        \ENDIF
    \ENDFOR
    \STATE $M' \gets M' \cup \{(m, m')\}$
\ENDFOR
\RETURN $M'$
\end{algorithmic}
\end{algorithm}

\textbf{Primer:} Koristeći skup zajedničkih jedinica $ I = \{3\} $, skraćuju se modeli i pravi novi skup modela:
\[
M' = \{((0, 0, 0, 1), '000'), ((0, 1, 0, 1), '010'), ((1, 0, 1, 1), '101')\}\text{.}
\] 

Skraćivanje modela uklanjanjem zajedničkih jedinica omogućava fokusiranje na preostale promenljive, čime se poboljšava efikasnost obrade u sledećim koracima. Ovaj korak pomaže u smanjenju složenosti problema. Kada se zajedničke jedinice uklone iz modela, preostaje manji broj promenljivih i njihovih vrednosti koje treba obraditi. Ovo smanjenje složenosti pojednostavljuje dalje analize i generisanje klauza, jer se sada razmatraju samo promenljive koje nisu jedinice u svim modelima. Time se značajno smanjuje broj varijacija koje treba razmotriti, što poboljšava efikasnost celokupnog algoritma i omogućava brže i preciznije rezultate.


Generisanje svih mogućih binarnih varijacija sa ponavljanjem predstavlja sledeći korak. Ove varijacije su osnova za stvaranje formule koja zadovoljava potpun skup modela.\\

\begin{algorithm}[H]
\caption{Generisanje formule}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE Broj promenljivih $n$, skup zajedničkih jedinica $J$, skup skraćenih model $S$, skup svih proširenih modela $E$
\ENSURE CNF formula $F$
\STATE $F \gets ""$
\FOR{$(e,c) \in E$}
    \IF{$c \notin S$}
        \STATE $C \gets [\texttt{ \phantom{}}]$ 
        \FOR{$j = 0$ \TO $|e| - 1$}
            \IF{$j \notin J$}
                \IF{$e_j = 1$}
                    \STATE $C.\texttt{append}("\neg X_{(j + 1)}")$
                \ELSE
                    \STATE $C.\texttt{append}("X_{(j + 1)}")$
                \ENDIF
            \ENDIF
        \ENDFOR
        \STATE $F \gets F + "\vee" + C$
    \ENDIF
\ENDFOR
\RETURN $F$
\end{algorithmic}
\end{algorithm}

\textbf{Primer:} Na osnovu skraćenih modela \{('000'), ('010'), ('101')\} i skupa zajedničkih jedinica, generišemo sve moguće klauze. Prvo, kreiraju se sve moguće binarne varijacije za preostale promenljive, za promenljive koje nisu zajedničke svim modelima. U ovom slučaju, ostaju promenljive $x_1$, $x_2$ i $x_3$, a njihove varijacije su '000', '001', '010', '011', '100', '101', '110', i '111'. Zatim, za svaku varijaciju koja nije prisutna među skraćenim modelima, formira se klauza koja predstavlja negaciju te varijacije. Na primer, varijacija '001' generiše klauzu $(x_1 \vee x_2 \vee \neg x_3)$. Konačno, klauza za zajedničku promenljivu $x_4$ se dodaje formuli, jer ona mora biti prisutna u svim modelima. Rezultat će biti:
\[
(x_1 \vee x_2 \vee \neg x_3) \wedge (x_1 \vee \neg x_2 \vee \neg x_3) \wedge (\neg x_1 \vee x_2 \vee x_3) \wedge (\neg x_1 \vee \neg x_2 \vee x_3) \wedge (\neg x_1 \vee \neg x_2 \vee \neg x_3) \wedge x_4
\]

Generisanje klauza na osnovu binarnih varijacija omogućava da se obuhvate sve moguće varijacije vrednosti promenljivih koje nisu prisutne u modelima. Kada se identifikuju sve binarne varijacije koje nisu zastupljene u modelima, za svaku od njih se formira odgovarajuća klauza. Kreiranjem klauza za te varijacije isključuju se vrednosti koje ne zadovoljavaju modele. Ovaj proces osigurava da formula ostane tačna za sve modele iz skupa i nijedan model van njega.


Kao završni korak, koristi se metoda rezolucije za pojednostavljenje formule. Rezolucija je ključna tehnika u logici koja pomaže u rešavanju problema sa logičkim izrazima tako što identifikuje i kombinuje klauze koje se mogu rešiti da bi se smanjio broj klauza i pojednostavila formula. Cilj rezolucije je da se eliminišu konfliktne i redundantne klauze, čime se formula pojednostavljuje i postaje efikasnija za dalje analize.

\textbf{Definicija.} Neka su \( C_1 \) i \( C_2 \) klauze, i neka su \( L_1 \) i \( L_2 \) komplementarni literali, takvi da se \( L_1 \) nalazi u \( C_1 \), a \( L_2 \) u \( C_2 \). Rezolventa klauza \( C_1 \) i \( C_2 \) po literalima \( L_1 \) i \( L_2 \) je klauza dobijena kao:
\[
R(C_1, C_2, L_1, L_2) = \left(C_1 \setminus \{L_1\}\right) \cup \left(C_2 \setminus \{L_2\}\right)
\]
Gde \( R \) predstavlja rezolventu klauzu.\\


\begin{theorem}
Neka su \( C_1 \) i \( C_2 \) klauze i \( R \) njihova rezolventa. Tada je:
\[
\{C_1, C_2\} \equiv \{C_1, C_2, R\}
\text{.}
\]
\end{theorem}

\begin{proof}
Neka je $I$ interpretacija za koju važi da je $I \models \{C_1, C_2, R\}$. Tada je trivijalno da važi $I \models \{C_1, C_2\}$. Obrnuto, pretpostavimo da je $I$ interpretacija za koju važi $I \models \{C_1, C_2\}$. Neka su $L$ i $\neg L$ literali po kojima se vrši rezolucija klauza $C_1$ i $C_2$, takvi da je $L \in C_1$ i $\neg L \in C_2$. Ako $I \models C_1$, onda mora važiti $I \models C_2 \setminus \{\neg L\}$, pa sledi da $I \models R$. Slično, ako $I \models C_2$, tada $I \models C_1 \setminus \{L\}$, pa $I \models R$.

\end{proof}
Ova teorema pokazuje da dodavanje rezolventne klauze \( R \) u skup klauza \( \{C_1, C_2\} \) ne menja skup modela koji zadovoljava te klauze. Drugim rečima, klauze \( C_1 \) i \( C_2 \) su ekvivalentne skupu klauza koji uključuje i njihovu rezolventu \( R \). Ova osobina rezolucije omogućava sistematsko pojednostavljenje klauza bez promene njihovih osnovnih logičkih svojstava.


U procesu redukcije, rezolucija se koristi za identifikaciju i eliminaciju neslaganja između klauza. Ako se pronađe par klauza koje sadrže komplementarne literale, one se mogu kombinovati da bi se formirala nova klauza koja ne uključuje te komplementarne literale. Ova nova klauza se zatim dodaje u skup klauza, a proces se ponavlja sve dok se ne postigne željeni oblik formule, kao što je Hornova forma, ili dok se ne ispune drugi kriterijumi za jednostavnost formule.

\begin{algorithm}[H]
\caption{Redukcija formule}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE CNF formula $F$
\ENSURE Reducirana Hornova formula $F'$
\STATE $F' \gets ""$
\STATE $klauze \gets \text{split}(\text{formula}, \&)$
\WHILE{$PostojiNeHornovaKlauza(klauze)$}
    \STATE $rezolvirane\_klauze \gets \emptyset$
    \STATE $rezolvirana\_klauza \gets \text{None}$
    \STATE $rezolviran \gets \text{False}$
    \FOR{$k1,k2 \in klauze$}
        \STATE $rezolvirana\_klauza, potrebne\_izmene \gets PrimeniRezoluciju(k1,k2)$
        \IF{$rezolvirana\_klauza \neq \text{None}$ \AND $potrebne\_izmene$}
            \STATE $rezolvirane\_klauze \gets rezolvirane\_klauze \cup \{rezolvirana\_klauza\}$
        \ENDIF
        \STATE $rezolviran \gets \text{True}$  \STATE $\textbf{break}$
    \ENDFOR
    \IF{$\neg rezolviran$}
        \STATE $klauze \gets originalne\_klauze$
        \STATE $klauze.shuffle()$
    \ENDIF
    \IF{$potrebne\_izmene$}
        \STATE $klauze \gets klauze \setminus \{k1\}$
        \STATE $klauze \gets klauze \setminus \{k2\}$
    \ENDIF
    \FOR{$klauza \in rezolvirane\_klauze$}
        \STATE $klauze \gets klauze \cup \{klauza\}$
    \ENDFOR
\ENDWHILE
\FOR{$klauza \in klauze$}
    \STATE $F' \gets F' + "\wedge" + klauza$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\textbf{Primer:} Primenom algoritma za redukciju formule na formulu dobijenu u prethodnom primeru, kao rezultat dobijemo:
\[
(\neg x_1 \vee \neg x_2 \vee \neg x_3) \wedge x_4 \wedge (x_1 \vee \neg x_3) \wedge (\neg x_1 \vee x_3)\text{.}
\]

Ovaj algoritam pruža efikasan način da se generiše Hornova formula koja zadovoljava sve specifikacije iz skupa modela. Ključni koraci uključuju prepoznavanje zajedničkih jedinica, skraćivanje modela, generisanje varijacija, formiranje CNF formule, i redukciju klauza do Hornove forme. Proces omogućava strukturirano i sistematično pristupanje problemu, čineći ga pogodnim za različite primene u oblasti logike i računarstva \cite{russell}.


Analiza vremenske složenosti algoritma za generisanje Hornove formule ključna je za razumevanje njegovih performansi, posebno kada se koristi za velike skupove modela. Iako je algoritam testiran na malim skupovima modela i pokazao zadovoljavajuće performanse, važno je sagledati kako se njegovo vreme izvršavanja ponaša sa povećanjem broja modela.

Algoritam se sastoji iz nekoliko glavnih faza, čija vremenska složenost se može analizirati na sledeći način:

\begin{itemize}
    \item \textbf{prepoznavanje zajedničkih jedinica} - ova faza uključuje iteraciju kroz sve modele i proveru da li su svi elementi na određenim pozicijama jednaki. Ako je broj modela \( m \) i dužina modela \( n \), tada je vremenska složenost ove faze \( O(m \cdot n) \), jer se za svaku poziciju u modelima proverava svaki model;
    
    \item \textbf{skraćivanje modela} - u ovoj fazi, za svaki model, uklanjaju se pozicije koje sadrže zajedničke jedinice. Ako je broj modela \( m \) i dužina svakog modela \( n \), skraćivanje se može smatrati kao \( O(m \cdot n) \), jer se za svaki model prolazi kroz sve pozicije i uklanjaju se zajedničke jedinice.
    
    \item \textbf{generisanje binarnih varijacija} - generisanje svih mogućih binarnih varijacija za \( n \) promenljivih dovodi do \( 2^n \) varijacija. Svaka varijacija se obrađuje i dodaje u skup klauza, što može biti eksponencijalno u odnosu na broj promenljivih. Dakle, vremenska složenost ove faze je \( O(2^n) \);
    
    \item \textbf{formulisanje klauza i rezolucija} - kada se generišu sve klauze, rezolucija se koristi za eliminaciju konflikata između klauza. Rezolucija između dva skupa klauza može dovesti do dodatnih klauza, a broj klauza može eksponencijalno rasti u odnosu na broj promenljivih. U najgorem slučaju, složenost može biti \( O(2^n) \) zbog potrebe za obradom svih mogućih klauza i njihovih kombinacija.
\end{itemize}

Na osnovu ove analize, jasno je da algoritam može postati veoma spor za velike skupove modela zbog eksponencijalne složenosti u vezi sa brojem promenljivih i brojem generisanih klauza. Iako je za male skupove modela performansa zadovoljavajuća, optimizacija ili korišćenje efikasnijih tehnika može biti neophodno za rad sa većim skupovima modela.

\section{Test podaci i njihovo generisanje}

Za evaluaciju performansi razvijenih algoritama, korišćeni su specijalno generisani testni podaci. Testni skupovi su predstavljali različite konfiguracije modela kako bi se obuhvatila različita scenarija i proverila efikasnost algoritama u različitim uslovima. 

Testni skupovi su generisani pomoću algoritma koji pravi modele sa binarnim vrednostima. Algoritam pravi nasumične varijacije sa ponavljanjem vrednosti promenljivih za zadati broj promenljivih $n$ i broj modela $m$, dok broj kreiranih jedinstvenih varijacija ne postane $m$. Ovi skupovi su zatim zapisani u tekstualne datoteke za dalju analizu i testiranje.

\textbf{Primer:} U nastavku možemo videti izgled tekstualne datoteke `TestInstances2.txt` (mali skup podataka):

\begin{lstlisting}[basicstyle=\ttfamily, frame=single]
0 0 0 1
0 1 0 1
0 0 1 0
0 1 0 0
0 1 1 0
1 0 1 0
0 0 0 0
1 0 0 1
1 0 0 0
0 0 1 1
\end{lstlisting}

\begin{algorithm}[H]
\caption{Generisanje testnih skupova}
\renewcommand{\algorithmicrequire}{\textbf{Ulaz:}}
\renewcommand{\algorithmicensure}{\textbf{Izlaz:}}
\begin{algorithmic}[1]
\REQUIRE Broj promenljivih $n$, broj modela $m$
\ENSURE Lista generisanih modela $L$ 
\STATE $L \gets \emptyset$
\WHILE{$|L| < m$}
    \STATE \textit{variation} $\gets [\text{random}(0, 1) \text{ for } i \text{ in } \text{range}(n)]$
    \STATE $L \gets L \cup \{variation\}$
\ENDWHILE
\RETURN $[L]$
\end{algorithmic}
\end{algorithm}

Za male testne skupove korišćeni su modeli sa četiri promenljive. Prvi mali skup uključivao je 4 valuacije u modelu, dok je drugi je imao 10 valuacija. Ovi mali skupovi su korišćeni za testiranje obe metaheuristike kao i algoritma grube sile. Testiranje na ovim skupovima omogućilo je poređenje tačnosti i efikasnosti metaheurističkih metoda u odnosu na klasičnu metodu grube sile. 

Osim testiranja metaheuristika i metode grube sile, na ovim malim skupovima testirano je i generisanje Hornove formule iz skupa modela. Iako generisanje Hornove formule nije bio primarni cilj istraživanja, uključivanje ove faze omogućilo je procenu efikasnosti i tačnosti algoritma za generisanje formula. Ova analiza pružila je uvid u dodatne aspekte performansi algoritama, pokazujući kako dobro algoritam može transformisati skup modela u odgovarajuću Hornovu formulu. Nažalost, zbog velike vremenske složenosti ovog algoritma, nije bilo moguće testirati njegov rad na velikim skupovima podataka.

Na velikim testnim skupovima, koji su uključivali modele sa 5, 6, 7, 8, 9 i 10 promenljivih, testirane su isključivo metaheuristike. Ovi veliki skupovi su sadržavali od 2 do 3 različita broja valuacija za svaki broj promenljivih. Testiranje ovih skupova sa metodom grube sile bilo je nepraktično zbog velike vremenske složenosti algoritma, što je rezultiralo predugim vremenima izvršavanja. 

Kao ilustraciju, radi boljeg razumevanja testnih podataka, razmotrićemo mali testni skup sa četiri promenljive. U ovom skupu, svaki model je predstavljen kao binarna sekvenca od četiri vrednosti, gde svaka vrednost može biti 0 ili 1. Evo primera skupa:

\begin{verbatim}
0 0 0 1
0 1 0 1
1 0 1 1
\end{verbatim}

U ovom primeru, svaki red predstavlja jedan model sa četiri promenljive. Svaki model je niz od četiri binarne vrednosti koje odgovaraju stanjima promenljive. Prvi model \texttt{0 0 0 1} pokazuje da su prve tri promenljive netačne (0), dok je poslednja promenljiva tačna (1).


Ovi testni skupovi i metodologija generisanja podataka omogućili su detaljnu analizu i upoređivanje performansi različitih algoritamskih pristupa. Proces generisanja podataka, zajedno sa evaluacijom rezultata na različitim skupovima, omogućio je dobijanje uvida u efikasnost i tačnost razvijenih algoritama, kao i identifikaciju mogućih područja za unapređenje.

\chapter{Implementacija}
U ovom poglavlju biće prikazani ključni aspekti implementacije algoritama. Takođe, biće pružen i kratak pregled eksperimentalnog okruženja u kojem je izvršeno testiranje, uključujući hardverske i softverske specifikacije računarskog sistema, kao i specifičnosti koje su uticale na implementaciju i izvršenje algoritma.



\section{Eksperimentalno okruženje}
Svi rezultati dobijeni u ovom istraživanju generisani su i analizirani u okruženju koje koristi \textit{Python} programski jezik i \textit{Jupyter notebook} za razvoj i testiranje. Eksperimentalno okruženje je postavljeno na računaru sa sledećim specifikacijama:
\begin{itemize}
    \item \textbf{Operativni sistem:} Ubuntu 22.04.4 LTS
    \item \textbf{Jezgro:} Linux 6.5.0-41-generic
\end{itemize}

Hardverska specifikacija računara korišćenog za testiranje su sledeće:
\begin{itemize}
    \item \textbf{Arhitektura:} x86-64
    \item \textbf{Procesor:} 12th Gen Intel Core i5-1235U x 12, 4.4GHz
    \item \textbf{RAM memorija:} Kingston 16GB DDR4
\end{itemize}

Programski kod\footnote{\url{https://github.com/NikolaBelak17/master}} je organizovan u šest skripti, od kojih se tri koriste za implementaciju algoritama i metaheuristika (metoda grube sile, VNS i pohlepna pertraga). Skripta ($generate\_test\_instance.ipynb$) omogućava generisanje dodatnih skupova podataka. Program se može testirati i bez pokretanja ove skripte jer postoje već generisani testni podaci. Ostale dve skripte ($test\_small.ipynb$ i $test\_large.ipynb$) izvršavaju algoritme nad definisanim skupovima podataka. Dizajnirane su tako da prvo pokrenu sve potrebne skripte sa algoritmima, a zatim testiraju i prikazuju rezultate testiranja algoritama.

Za pokretanje skripti, potrebno je samo izvršiti odgovarajuće komande unutar Jupyter okruženja, osiguravajući da su sve potrebne biblioteke instalirane. Ove biblioteke omogućavaju lako upravljanje podacima i fleksibilnost u eksperimentalnom procesu. Možete ih instalirati korišćenjem sledeće komande u terminalu:
\begin{verbatim}
    pip install naziv_biblioteke
\end{verbatim}
Korišćene su sledeće biblioteke: 
\begin{itemize}
    \item \textbf{NumPy:} Koristi se za rad sa nizovima i matematičkim operacijama.
    \item \textbf{Random:} Omogućava generisanje slučajnih brojeva.
    \item \textbf{OS:} Koristi se za interakciju sa operativnim sistemom.
    \item \textbf{RE:} Omogućava rad sa regularnim izrazima za pretragu i manipulaciju tekstom.
    \item \textbf{Itertools}: Koristi se za efikasno generisanje iterativnih funkcija.
    \item \textbf{Time}: Omogućava merenje vremena izvršavanja.
    \item \textbf{Matplotlib:} Omogućava pravljenje grafičkog prikaza i vizualizacije podataka.
\end{itemize}

\section{Implementacija algoritama}
U ovom delu biće detaljno opisana implementacija algoritama korišćenih u istraživanju. Fokus će biti na metodi grube sile, metodi promenljive okoline, pohlepnoj pretrazi, kao i algoritmu za generisanje Hornovih formula.

Sva tri navedena algoritma za rešavanje problema optimizacije koriste metodu \texttt{is\_horn\_theory}, koja je ključna za proveru da li trenutni skup valuacija predstavlja Hornovu teoriju. Ova metoda proverava da li je zadata valuacija u početnom skupu modela:

\begin{lstlisting}[language=Python]
def is_horn_theory(assignment, M):
    if tuple(assignment) not in M:
        return False
    return True
\end{lstlisting}
\vspace{0.5cm}

Implementacija metode grube sile koristi jednostavan pristup isprobavanja svih mogućih rešenja. Na početku se \texttt{horn\_core} postavlja na praznu listu, u koju će biti smešteno trenutno najbolje jezgro. Zatim se prolazi kroz sve moguće varijacije modela iz početnog skupa za različite veličine, od 1 do broj modela u skupu, koristeći funkciju \texttt{combinations} iz biblioteke \texttt{itertools}. Za svaku varijaciju se proverava da li rešenje bitovske konjunkcije svih mogućih parova valuacija pripada početnom skupu, korišćenjem  metode \texttt{is\_horn\_theory}. Ako je varijacija validna Hornova teorija i duža od do tada najboljeg jezgra, ažurira se \texttt{horn\_core}. Na kraju, funkcija vraća najbolje pronađeno jezgro.

Implementacija algortima pohlepne pretrage iterativno gradi rešenje, dodajući valuacije koje proširuju trenutni skup, dokle god taj prošireni skup ostaje validna Hornova teorija. Algoritam započinje tako što se inicijalizuje prazan skup \texttt{horn\_core} koji predstavlja trenutno jezgro i skup \texttt{used\_assignment} u koji će biti smeštene već korišćene valuacije. Zatim, slučajnim odabirom iz početnog skupa modea, korišćenjem funkcije \texttt{choice} iz biblioteke \texttt{random}, se bira početna valuacija koja se dodaje u oba skupa.

U glavnoj petlji algoritma, dokle god nisu iskorišćene sve dostupne valuacije, slučajno se bira nova valuacija koja nije korišćena. Ova nova valuacija se privremeno dodaje u \texttt{horn\_core}, formirajući novi kandidat za jezgro \texttt{new\_core}:

\begin{lstlisting}[language=Python]
for _ in range(len(M)):
    if len(used_assignment) == len(M):
        break
    while True:
        random_assignment = random.choice(M)
        if random_assignment not in used_assignment:
            break
    used_assignment.add(random_assignment)
    new_core = horn_core | set([random_assignment])
\end{lstlisting}
\vspace{0.5cm}

Zatim, za svaki par valuacija u tom novom kandidatu se izračunava bitovska konjunkcija. Ovo se postiže korišćenjem funkcija \texttt{zip} i \texttt{all} koje su deo standardne $Python$ biblioteke. Funkcija \texttt{zip} iterira kroz oba modela paralelno, spajajući odgovarajuće promenljive, dok \texttt{all} proverava da li su sve promenljive istovremeno istinite u oba modela. Rezultat ove operacije je nova valuacija koja se konvertuje u binarni format:

\begin{lstlisting}[language=Python]
for pair in combinations(new_core, 2):
    new_assignment = [all(var_values) for var_values in zip(*pair)]
    new_assignment = [int(val) for val in new_assignment]
\end{lstlisting}
\vspace{0.5cm}

Ako bilo koje rešenje bitovske konjunkcije ne zadovoljava uslov da pripada početnom skupu modela, što se proverava korišćenjem funkcije \texttt{is\_horn\_theory}, kandidat za jezgro se odbacuje. Ukoliko sve valuacije zadovolje uslov, novi kandidat postaje novo jezgro \texttt{horn\_core}.

Tokom svake iteracije, dužina trenutnog jezgra se beleži u listi \texttt{cores}, koja prati razvoj jezgra kroz algoritam. Na kraju, algoritam vraća konačno Hornovo jezgro \texttt{horn\_core} i listu \texttt{cores} koja prikazuje rast jezgra tokom pretrage.

Metoda promenjlivih okolina je implementirana u nekoliko ključnih koraka za optimizaciju rešenja. Algoritam započinje inicijalizacijom početnog Hornovog jezgra \texttt{horn\_core}, koje se inicijalno postavlja na prazan skup, a zatim slučajnim odabirom iz početnog skupa modela bira valuacija koja se dodaje u jezgro. Algoritam se oslanja na dve osnovne funkcije \texttt{shaking} i \texttt{local\_search}.

Funkcija \texttt{shaking} se koristi za generisanje izmenjenog jezgra uklanjanjem slučajno izabrane valuacije iz trenutnog jezgra:

\begin{lstlisting}[language=Python]
def shaking(current_core, M):
    new_core = set(current_core)
    if new_core:
        assignment_to_remove = random.choice(list(new_core))
        new_core.remove(assignment_to_remove)
    return new_core
\end{lstlisting}
\vspace{0.5cm}

Nakon razmrdavanja, novo jezgro se prosleđuje funkciji \texttt{local\_search}, koja dodaje nove valuacije i pokušava da pronađe bolje rešenje, pod uslovom da prošireni skup ostaje validna Hornova teorija kao prethodno opisan algoritam pohlepne pretrage.

Tokom svake iteracije, veličina trenutnog jezgra se beleži u listi \texttt{cores}, koja prati njegov razvoj. Algoritam koristi parametre \texttt{max\_iterations} za broj ukupnih iteracija i \texttt{k\_max} za broj različitih okolina koje se istražuju u svakoj iteraciji. Na kraju, funkcija \texttt{variable\_neighborhood\_search} vraća konačno Hornovo jezgro \texttt{horn\_core} i listu \texttt{cores} koja prikazuje rast jezgra tokom pretrage.

Implementacija algoritma za generisanje Hornove formule počinje identifikacijom zajedničkih jedinica u datom skupu modela. Funkcija \texttt{find\_common\_ones} prolazi kroz sve modele i identifikuje promenljive koje su jednake 1 u svim modelima. Zatim se koristi funkcija \texttt{shorten\_models} kako bi se ovi modeli skratili uklanjanjem zajedničkih jedinica. Ova funkcija koristi metodu \texttt{join} iz standardne $Python$ biblioteke, koja spaja elemente liste u jedan string.

Nakon toga, funkcija \texttt{generate\_all\_combinations} generiše sve moguće varijacije binarnih vrednosti za promenljive koje nisu zajedničke jedinice. Svaka od ovih kombinacija se proširuje kako bi se ponovo uključile zajedničke jedinice.

Sledeći korak je generisanje formule u konjuktivnoj normalnoj formi. Funkcija \texttt{generate\_formula} prolazi kroz sve moguće varijacije i generiše CNF klauze za one varijacije koje nisu prisutne u skraćenim modelima. Svaka klauza se sastoji od literala koji su suprotne vrednosti odgovarajućih promenljivih. Kada je vrednost promenljive 1, koristi se negativni literal, a kada je vrednost 0, koristi se pozitvni literal. Na kraju se formula dopunjuje dodavanjem literala koji odgovaraju zajedničkim jedinicama.


\begin{lstlisting}[language=Python]
formula=""
    for i in range(len(all_models)):
        if all_models[i][1] not in [model[1] for model in shortened_models]:
            cnf_clauses = []
            for j, bit  in enumerate(all_models[i][0]):
                if j not in common_ones:
                    if bit == "1":
                        cnf_clauses.append(f"~x{j+1}")
                    else:
                        cnf_clauses.append(f"x{j+1}")

            formula += "(" + " | ".join(cnf_clauses) + ") & "   
    for i in common_ones:
        formula += f"x{i+1} & "
    formula = formula[:-3]
\end{lstlisting}
\vspace{0.5cm}

Da bi se osigurala ispravnost Hornove formule, funkcija \texttt{reduce\_formula} koristi rezoluciju klauza. Ova funkcija iterativno proverava da li postoji neka klauza sa više od jednog pozitivnog literala i pokušava da je zameni sa novom, pojednostavljenom klauzom koristeći rezoluciju između parova klauza pomoću funkcije \texttt{resolve\_clause}. Ako se uspešno izvrši rezolucija, originalne klauze se zamenjuju novom, dok se formula ne sastoji isključivo od Hornovih klauza. Konačan rezultat je Hornova formula u CNF obliku.

Iako procesor ima 12 jezgara, algoritmi nisu implementirani za paralelno izvršavanje, što može uticati na brzinu obrade. Implementacija svih struktura podataka poput skupova, listi i uređenih parova, koristi standardne biblioteke $Python$ jezika, kao što su \texttt{set}, \texttt{list} i \texttt{tuple}. Pomoćni algoritmi za mešanje i izbor elementa iz skupa su realizovani korišćenjem ugrađenih funkcija poput \texttt{shuffle} i \texttt{choice}. Generisanje test instanci koristi ugrađenu biblioteku \texttt{random} i ti podaci su smešteni u tekstualnim datotekama, što omogućava lakšu organizaciju i ponovnu upotrebu i analizu tih podataka.

\chapter{Evaluacija algoritama}
U ovom poglavlju biće prikazani eksperimentalni rezultati izvršavanja algoritama. Prvo će biti analizirani rezultati za male testne instance, a zatim za velike testne instance.

Mali testni skupovi omogućavaju detaljno ispitivanje performansi algoritama u kontrolisanim uslovima. Ovi testovi su korisni za proveru tačnosti i pouzdanosti implementacije algoritama na jednostavnim i manje zahtevnim primerima. 

Analiza malih testnih primera treba da nam pokaže da li algoritmi funkcionišu kako je očekivano i da li su rezultati u skladu sa onima dobijenim putem metode grube sile. Ova konzistentnost potvrđuje tačnost i pouzdanost implementacija korišćenih algoritama. Male instance omogućavaju detaljnu proveru ispravnosti svakog koraka u algoritmu, osiguravajući da implementacija funkcioniše kako je predviđeno.

Na slikama \ref{fig:slika1} i \ref{fig:slika2} prikazani su rezultati rada algoritma grube sile, pohlepne pretrage i VNS algoritma na malim test primerima. Rezultati uključuju detaljne informacije o ulaznim podacima (veličinu ulaznog skupa modela i njegove članove), broj valuacija u maksimalnom Hornovom jezgru, članove maksimalnog Hornovog jezgra, kao i formule generisane na osnovu Hornovog jezgra (CNF formula i Hornova formula dobijena redukcijom CNF formule). Svaka slika daje uvid u performanse korišćenih metoda i omogućava analizu njihove tačnosti.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{small_test_1.png}
    \caption{Rezultati za mali testni skup 1}
    \label{fig:slika1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{small_test_2.png}
    \caption{Rezultati za mali testni skup 2}
    \label{fig:slika2}
\end{figure}

Rezultati testiranja malih testnih skupova su u skladu sa očekivanjima. Rezultati pokazuju da su algoritmi uspeli da pronađu maksimalna Hornova jezgra kako je predviđeno, potvrđujući tačnost i pouzdanost njihovih implementacija. Ovi testovi pružaju osnovu za analizu performansi na složenijim i većim testnim skupovima.

Prethodne studije i teorijska očekivanja sugerišu da bi VNS algoritam trebalo da nadmaši pohlepnu pretragu u pronalaženju najvećih Hornovih jezgara. Očekuje se da VNS, zbog svoje sposobnosti da koristi lokalne pretrage i promenljivu strukturu susedstva, pronađe bolja rešenja u poređenju sa pohlepnom pretragom. Pohlepna pretraga, iako brza i jednostavna, može praviti kompromise u kvalitetu rešenja zbog svoje determinističke prirode i sklonosti da se zaglavi u lokalnim optimumima. Teorijski, pohlepna pretraga je pogodna za situacije kada je brzina kritični faktor, ali njena sposobnost da pronađe globalno optimalna rešenja je ograničena.

U nastavku su prikazani rezultati testiranja algoritma VNSa i pohlepne pretrage na tri odabrana velika testna skupa. Na slikama \ref{fig:test1_greedy_performance}, \ref{fig:test1_vns_performance}, \ref{fig:test2_greedy_performance}, \ref{fig:test2_vns_performance}, \ref{fig:test3_greedy_performance}, i \ref{fig:test3_vns_performance} mogu se videti stubasti dijagrami koji prikazuju veličinu Hornovog jezgra za 20 pokretanja ovih algoritama, kao i promenu veličine jezgra tokom iteracija jednog pokretanja algoritma. Svaka slika omogućava uvid u ova dva aspekta performansi algoritama, varijacije u veličini jezgra između različitih pokretanja i dinamiku veličine jezgra kroz iteracije. Tabela \ref{tab:test_results} sadrži detaljne rezultate performansi. Ova tabela prikazuje redni broj testnog skupa ($M$), broj promenljivih ($N$), broj modela u testnom skupu ($|M|$), prosečno vreme po pokretanju algoritma ($T_{avg}$) i ukupno vreme izvršavanja svih 20 pokretanja algoritma ($T_{tot})$, kao i prosečnu veličinu najboljeg Hornovog jezgra za sva pokretanja algoritma ($V_{avg}$) i veličinu najboljeg jezgra pronađenog tokom svih pokretanja ($V_{tot}$). Veličina jezgra predstavlja broj modela uključenih u to jezgru.
\newpage


\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test1_greedy_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test1_greedy_performance2.png}
    }
    \caption{Grafik performansi pohlepne pretrage na testnom skupu sa 8 promenljivih i 100 modela}
    \label{fig:test1_greedy_performance}
\end{figure}


\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test1_vns_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test1_vns_performance2.png}
    }
    \caption{Grafik performansi VNSa na testnom skupu sa 8 promenljivih i 100 modela}
    \label{fig:test1_vns_performance}
\end{figure}

\vspace{2cm}

\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test2_greedy_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test2_greedy_performance2.png}
    }
    \caption{Grafik performansi pohlepne pretrage na testnom skupu sa 8 promenljivih i 200 modela}
    \label{fig:test2_greedy_performance}
\end{figure}

\vspace{2cm}

\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test2_vns_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test2_vns_performance2.png}
    }
    \caption{Grafik performansi VNSa na testnom skupu sa 8 promenljivih i 200 modela}
    \label{fig:test2_vns_performance}
\end{figure}

\vspace{2cm}

\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test3_greedy_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test3_greedy_performance2.png}
    }
    \caption{Grafik performansi pohlepne pretrage na testnom skupu sa 9 promenljivih i 150 modela}
    \label{fig:test3_greedy_performance}
\end{figure}

\vspace{2cm}

\begin{figure}[H]
    \centering
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test3_vns_performance.png}
    }
    \hfill
    \subfigure{
        \includegraphics[width=0.45\textwidth]{test3_vns_performance2.png}
    }
    \caption{Grafik performansi VNSa na testnom skupu sa 9 promenljivih i 150 modela}
    \label{fig:test3_vns_performance}
\end{figure}

\vspace{1cm}

\renewcommand{\arraystretch}{2} % Povecava visinu redova
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|r|r|r|rrrr|rrrr|}
\hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{M}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{N}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{|M|}}} & \multicolumn{4}{c|}{\textbf{Pohlepna pretraga}} & \multicolumn{4}{c|}{\textbf{VNS}} \\ \cline{4-11} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{\textbf{T_{avg}}} & \multicolumn{1}{c|}{\textbf{T_{tot}}} & \multicolumn{1}{c|}{\textbf{V_{avg}}} & \multicolumn{1}{c|}{\textbf{V_{tot}}} & \multicolumn{1}{c|}{\textbf{T_{avg}}} & \multicolumn{1}{c|}{\textbf{T_{tot}}} & \multicolumn{1}{c|}{\textbf{V_{avg}}} & \multicolumn{1}{c|}{\textbf{V_{tot}}} \\ \hline
Skup 1 & 5 & 15 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.010} & \multicolumn{1}{r|}{5.85} & 7 & \multicolumn{1}{r|}{0.007} & \multicolumn{1}{r|}{0.143} & \multicolumn{1}{r|}{6.60} & 7 \\ \hline
Skup 2 & 5 & 25 & \multicolumn{1}{r|}{0.002} & \multicolumn{1}{r|}{0.031} & \multicolumn{1}{r|}{16.75} & 18 & \multicolumn{1}{r|}{0.046} & \multicolumn{1}{r|}{0.920} & \multicolumn{1}{r|}{17.55} & 18 \\ \hline
Skup 3 & 6 & 30 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.015} & \multicolumn{1}{r|}{8.25} & 10 & \multicolumn{1}{r|}{0.022} & \multicolumn{1}{r|}{0.431} & \multicolumn{1}{r|}{9.35} & 10 \\ \hline
Skup 4 & 6 & 50 & \multicolumn{1}{r|}{0.003} & \multicolumn{1}{r|}{0.056} & \multicolumn{1}{r|}{19.80} & 24 & \multicolumn{1}{r|}{0.146} & \multicolumn{1}{r|}{2.914} & \multicolumn{1}{r|}{21.30} & 24 \\ \hline
Skup 5 & 7 & 60 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.029} & \multicolumn{1}{r|}{11.40} & 17 & \multicolumn{1}{r|}{0.128} & \multicolumn{1}{r|}{2.566} & \multicolumn{1}{r|}{16.75} & 22 \\ \hline
Skup 6 & 7 & 100 & \multicolumn{1}{r|}{0.008} & \multicolumn{1}{r|}{0.166} & \multicolumn{1}{r|}{25.55} & 34 & \multicolumn{1}{r|}{0.833} & \multicolumn{1}{r|}{16.665} & \multicolumn{1}{r|}{31.40} & 37 \\ \hline
Skup 7 & 8 & 50 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.012} & \multicolumn{1}{r|}{5.40} & 8 & \multicolumn{1}{r|}{0.043} & \multicolumn{1}{r|}{0.861} & \multicolumn{1}{r|}{8.75} & 10 \\ \hline
Skup 8 & 8 & 100 & \multicolumn{1}{r|}{0.002} & \multicolumn{1}{r|}{0.044} & \multicolumn{1}{r|}{11.85} & 17 & \multicolumn{1}{r|}{0.218} & \multicolumn{1}{r|}{4.351} & \multicolumn{1}{r|}{13.30} & 17 \\ \hline
Skup 9 & 8 & 200 & \multicolumn{1}{r|}{0.045} & \multicolumn{1}{r|}{0.896} & \multicolumn{1}{r|}{39.20} & 50 & \multicolumn{1}{r|}{4.646} & \multicolumn{1}{r|}{92.920} & \multicolumn{1}{r|}{41.95} & 54 \\ \hline
Skup 10 & 9 & 75 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.016} & \multicolumn{1}{r|}{5.50} & 8 & \multicolumn{1}{r|}{0.049} & \multicolumn{1}{r|}{0.974} & \multicolumn{1}{r|}{6.25} & 8 \\ \hline
Skup 11 & 9 & 150 & \multicolumn{1}{r|}{0.004} & \multicolumn{1}{r|}{0.085} & \multicolumn{1}{r|}{13.20} & 18 & \multicolumn{1}{r|}{0.535} & \multicolumn{1}{r|}{10.703} & \multicolumn{1}{r|}{17.90} & 29 \\ \hline
Skup 12 & 9 & 225 & \multicolumn{1}{r|}{0.030} & \multicolumn{1}{r|}{0.600} & \multicolumn{1}{r|}{28.40} & 35 & \multicolumn{1}{r|}{5.008} & \multicolumn{1}{r|}{100.158} & \multicolumn{1}{r|}{33.60} & 40 \\ \hline
Skup 13 & 10 & 100 & \multicolumn{1}{r|}{0.001} & \multicolumn{1}{r|}{0.024} & \multicolumn{1}{r|}{6.10} & 12 & \multicolumn{1}{r|}{0.134} & \multicolumn{1}{r|}{2.675} & \multicolumn{1}{r|}{9.75} & 13 \\ \hline
Skup 14 & 10 & 200 & \multicolumn{1}{r|}{0.006} & \multicolumn{1}{r|}{0.116} & \multicolumn{1}{r|}{12.20} & 19 & \multicolumn{1}{r|}{0.684} & \multicolumn{1}{r|}{13.673} & \multicolumn{1}{r|}{14.00} & 20 \\ \hline
Skup 15 & 10 & 300 & \multicolumn{1}{r|}{0.008} & \multicolumn{1}{r|}{0.158} & \multicolumn{1}{r|}{13.20} & 18 & \multicolumn{1}{r|}{1.409} & \multicolumn{1}{r|}{28.189} & \multicolumn{1}{r|}{17.80} & 22 \\ \hline
\end{tabular}%
}
\caption{Rezultati na svim velikim testnim skupovima}
\label{tab:test_results}
\end{table}

Rezultati testiranja velikih testnih skupova potvrđuju prethodna očekivanja. VNS algoritam zaista nadmašuje pohlepnu pretragu u pronalaženju većih Hornovih jezgara. Na primer, na testnom skupu 12, VNS je pronašao jezgro veličine 40, dok je pohlepna pretraga pronašla jezgro veličine 35. Ovi rezultati potvrđuju da VNS koristi svoje napredne tehnike pretrage kako bi pronašao globalno bolja rešenja.

Takođe, pohlepna pretraga pokazuje brže vreme izvršavanja, ali često sa većim oscilacijama u kvalitetu rešenja tokom različitih iteracija. Ove oscilacije ukazuju na njenu sklonost da se zaglavi u lokalnim optimumima, što je u skladu sa teorijskim očekivanjima. VNS se, s druge strane, pokazuje kao robustan pristup u pronalaženju rešenja koja pohlepna pretraga može prevideti, što potvrđuje njegovu prednost u preciznosti i stabilnosti rešenja.

Dobijeni rezultati su u skladu sa postojećim istraživanjima, koji sugerišu da VNS pruža bolje rezultate u pronalaženju globalno optimalnih rešenja. Dok pohlepna pretraga nudi prednosti u brzini i jednostavnosti, prethodne studije su istakle da VNS koristi složenije tehnike za izbegavanje lokalnih optimuma, što je evidentno u njegovoj sposobnosti da dosledno identifikuje veća jezgra u poređenju sa pohlepnom pretragom.

U zaključku, dok VNS pokazuje superiornost u preciznosti, pohlepna pretraga ostaje važan alat zbog svoje jednostavnosti i brzine. Izbor između ova dva algoritma zavisi od specifičnih potreba aplikacije i raspoloživih resursa. Ova analiza omogućava donošenje informisanih odluka o tome koji algoritam koristiti u zavisnosti od specifičnih zahteva problema.

\chapter{Zaključak i pravac daljeg rada}

U ovom radu razmotrena je problematika pronalaženja maksimalnog Hornovog jezgra, koristeći različite algoritme i tehnike za evaluaciju efikasnosti pristupa. Eksperimenti su sprovedeni na malim i velikim skupovima podataka. Analizom su obuhvaćeni kako metaheuristički pristupi, kao što su metoda promenljivih okolina (VNS) i pohlepna pretraga, tako i klasična metoda grube sile. 

Eksperimentalni rezultati su pokazali da metaheuristički algoritmi pružaju značajnu prednost u smislu efikasnosti prilikom obrade velikih skupova podataka, dok pristup grube sile ostaje koristan za male instance zbog svoje tačnosti.
Analizom rezultata na velikim skupovima podataka može se zaključitit da VNS pruža nešto bolje rezultate u poređenju sa pohlepnom pretragom, što ukazuje na njegovu superiornost u ovom kontekstu.

Može se zaključiti da su metaheuristički algoritmi, kao što su metoda promenljivih okolina i pohlepna pretraga, veoma korisni za rešavanje problema maksimalnog Hornovog jezgra zbog svoje sposobnosti da nalaze približna rešenja u razumnom vremenskom okviru.

Razvijeni algoritam za generisanje Hornove formule pokazao je zadovoljavajuće rezultate u testiranju, ali postoje mogućnosti za dalja unapređenja. Trenutna verzija algoritma koristi osnovne tehnike za generisanje formula, ali u budućem radu bi moglo biti korisno implementirati sofisticiranije metode koje bi mogle poboljšati kvalitet generisanih formula i ubrzati proces generacije.

Za budući rad, preporučuje se dalja optimizacija postojećih metaheurističkih algoritama kako bi se poboljšala njihova tačnost i brzina, posebno u kontekstu vrlo velikih skupova podataka. Takođe, istraživanje novih metaheurističkih pristupa i njihova komparacija sa tradicionalnim metodama može pružiti dodatne uvide u efikasnost različitih tehnika. Implementacija naprednih tehnika kao što su hibridni algoritmi, koji kombinuju prednosti različitih metaheuristika, mogla bi biti korisna za dalje unapređenje rešenja problema maksimalnog Hornovog jezgra.

Pored toga, uvođenje novih evaluacijskih kriterijuma i testiranje na različitim vrstama instanci može doprineti razumevanju ograničenja i prednosti trenutnih metoda. Takođe, istraživanje mogućnosti primene razvijenih algoritama u drugim sličnim problemima i oblastima može otvoriti nove pravce istraživanja i primene.

Zaključno, ovaj rad pruža koristan doprinos razumevanju i primeni metaheurističkih tehnika za rešavanje kompleksnih problema, kao što je problem pronalaženja maksimalnog Hornovog jezgra. Istraživanje je omogućilo uvid u efikasnost različitih metoda i njihove prednosti i ograničenja. Takođe, pružena su osnova i smernice za buduća istraživanja i unapređenja, otvarajući prostor za dalje inovacije i optimizacije u ovoj oblasti.

% \lstinputlisting[caption=Sample Code Listing C++, label={lst:listing-cpp}, language=C++]{./code1.cpp}
% ------------------------------------------------------------------------------
% \pangrami

% \pangrami

% ------------------------------------------------------------------------------
% Literatura
% ------------------------------------------------------------------------------
\literatura

% ==============================================================================
% Završni deo teze i prilozi
\backmatter
% ==============================================================================

% ------------------------------------------------------------------------------
% Biografija kandidata
\begin{biografija}
  \textbf{Nikola Belaković} je rođen u Kraljevu 14. septembra 2000. godine.
  Išao je u osnovnu školu „Milun Ivanović” u Kraljevu, završio je odličnim uspehom
  i bio nagrađen Vukovom diplomom. Nakon završene osnovne škole
  upisao je prirodno-matematički smer „Gimanzije Kraljevo”.
  Po završetku srednje škole, odlučuje da upiše smer Informatika na Matematičkom fakultetu u Beogradu.
  Osnovne studije završava u roku od četiri godine i upisuje master studije na istom smeru.
  

\end{biografija}
% ------------------------------------------------------------------------------

\end{document}